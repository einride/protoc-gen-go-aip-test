// Code generated by protoc-gen-go-aip-test. DO NOT EDIT.

package aiplatformpb

import (
	context "context"
	cmpopts "github.com/google/go-cmp/cmp/cmpopts"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	proto "google.golang.org/protobuf/proto"
	protocmp "google.golang.org/protobuf/testing/protocmp"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	assert "gotest.tools/v3/assert"
	strings "strings"
	testing "testing"
	time "time"
)

// TensorboardServiceTestSuiteConfigProvider is the interface to implement to decide which resources
// that should be tested and how it's configured.
type TensorboardServiceTestSuiteConfigProvider interface {
	// TensorboardServiceTensorboard should return a config, or nil, which means that the tests will be skipped.
	TensorboardServiceTensorboard(t *testing.T) *TensorboardServiceTensorboardTestSuiteConfig
	// TensorboardServiceTensorboardExperiment should return a config, or nil, which means that the tests will be skipped.
	TensorboardServiceTensorboardExperiment(t *testing.T) *TensorboardServiceTensorboardExperimentTestSuiteConfig
	// TensorboardServiceTensorboardRun should return a config, or nil, which means that the tests will be skipped.
	TensorboardServiceTensorboardRun(t *testing.T) *TensorboardServiceTensorboardRunTestSuiteConfig
	// TensorboardServiceTensorboardTimeSeries should return a config, or nil, which means that the tests will be skipped.
	TensorboardServiceTensorboardTimeSeries(t *testing.T) *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig
}

// testTensorboardService is the main entrypoint for starting the AIP tests.
func testTensorboardService(t *testing.T, s TensorboardServiceTestSuiteConfigProvider) {
	testTensorboardServiceTensorboard(t, s)
	testTensorboardServiceTensorboardExperiment(t, s)
	testTensorboardServiceTensorboardRun(t, s)
	testTensorboardServiceTensorboardTimeSeries(t, s)
}

func testTensorboardServiceTensorboard(t *testing.T, s TensorboardServiceTestSuiteConfigProvider) {
	t.Run("Tensorboard", func(t *testing.T) {
		config := s.TensorboardServiceTensorboard(t)
		if config == nil {
			t.Skip("Method TensorboardServiceTensorboard not implemented")
		}
		if config.Service == nil {
			t.Skip("Method TensorboardServiceTensorboard.Service() not implemented")
		}
		if config.Context == nil {
			config.Context = func() context.Context { return context.Background() }
		}
		config.test(t)
	})
}

func testTensorboardServiceTensorboardExperiment(t *testing.T, s TensorboardServiceTestSuiteConfigProvider) {
	t.Run("TensorboardExperiment", func(t *testing.T) {
		config := s.TensorboardServiceTensorboardExperiment(t)
		if config == nil {
			t.Skip("Method TensorboardServiceTensorboardExperiment not implemented")
		}
		if config.Service == nil {
			t.Skip("Method TensorboardServiceTensorboardExperiment.Service() not implemented")
		}
		if config.Context == nil {
			config.Context = func() context.Context { return context.Background() }
		}
		config.test(t)
	})
}

func testTensorboardServiceTensorboardRun(t *testing.T, s TensorboardServiceTestSuiteConfigProvider) {
	t.Run("TensorboardRun", func(t *testing.T) {
		config := s.TensorboardServiceTensorboardRun(t)
		if config == nil {
			t.Skip("Method TensorboardServiceTensorboardRun not implemented")
		}
		if config.Service == nil {
			t.Skip("Method TensorboardServiceTensorboardRun.Service() not implemented")
		}
		if config.Context == nil {
			config.Context = func() context.Context { return context.Background() }
		}
		config.test(t)
	})
}

func testTensorboardServiceTensorboardTimeSeries(t *testing.T, s TensorboardServiceTestSuiteConfigProvider) {
	t.Run("TensorboardTimeSeries", func(t *testing.T) {
		config := s.TensorboardServiceTensorboardTimeSeries(t)
		if config == nil {
			t.Skip("Method TensorboardServiceTensorboardTimeSeries not implemented")
		}
		if config.Service == nil {
			t.Skip("Method TensorboardServiceTensorboardTimeSeries.Service() not implemented")
		}
		if config.Context == nil {
			config.Context = func() context.Context { return context.Background() }
		}
		config.test(t)
	})
}

type TensorboardServiceTestSuite struct {
	T *testing.T
	// Server to test.
	Server TensorboardServiceServer
}

func (fx TensorboardServiceTestSuite) TestTensorboard(ctx context.Context, options TensorboardServiceTensorboardTestSuiteConfig) {
	fx.T.Run("Tensorboard", func(t *testing.T) {
		options.Context = func() context.Context { return ctx }
		options.Service = func() TensorboardServiceServer { return fx.Server }
		options.test(t)
	})
}

func (fx TensorboardServiceTestSuite) TestTensorboardExperiment(ctx context.Context, options TensorboardServiceTensorboardExperimentTestSuiteConfig) {
	fx.T.Run("TensorboardExperiment", func(t *testing.T) {
		options.Context = func() context.Context { return ctx }
		options.Service = func() TensorboardServiceServer { return fx.Server }
		options.test(t)
	})
}

func (fx TensorboardServiceTestSuite) TestTensorboardRun(ctx context.Context, options TensorboardServiceTensorboardRunTestSuiteConfig) {
	fx.T.Run("TensorboardRun", func(t *testing.T) {
		options.Context = func() context.Context { return ctx }
		options.Service = func() TensorboardServiceServer { return fx.Server }
		options.test(t)
	})
}

func (fx TensorboardServiceTestSuite) TestTensorboardTimeSeries(ctx context.Context, options TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) {
	fx.T.Run("TensorboardTimeSeries", func(t *testing.T) {
		options.Context = func() context.Context { return ctx }
		options.Service = func() TensorboardServiceServer { return fx.Server }
		options.test(t)
	})
}

type TensorboardServiceTensorboardTestSuiteConfig struct {
	currParent int

	// Service should return the service that should be tested.
	// The service will be used for several tests.
	Service func() TensorboardServiceServer
	// Context should return a new context.
	// The context will be used for several tests.
	Context func() context.Context
	// The parents to use when creating resources.
	// At least one parent needs to be set. Depending on methods available on the resource,
	// more may be required. If insufficient number of parents are
	// provided the test will fail.
	Parents []string
	// Create should return a resource which is valid to create, i.e.
	// all required fields set.
	Create func(parent string) *Tensorboard
	// Update should return a resource which is valid to update, i.e.
	// all required fields set.
	Update func(parent string) *Tensorboard
	// Patterns of tests to skip.
	// For example if a service has a Get method:
	// Skip: ["Get"] will skip all tests for Get.
	// Skip: ["Get/persisted"] will only skip the subtest called "persisted" of Get.
	Skip []string
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) test(t *testing.T) {
	t.Run("Create", fx.testCreate)
	t.Run("Get", fx.testGet)
	t.Run("Update", fx.testUpdate)
	t.Run("List", fx.testList)
	t.Run("Delete", fx.testDelete)
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) testCreate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no parent is provided.
	t.Run("missing parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboard(fx.Context(), &CreateTensorboardRequest{
			Parent:      "",
			Tensorboard: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboard(fx.Context(), &CreateTensorboardRequest{
			Parent:      "invalid resource name",
			Tensorboard: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// The method should fail with InvalidArgument if the resource has any
	// required fields and they are not provided.
	t.Run("required fields", func(t *testing.T) {
		fx.maybeSkip(t)
		t.Run(".display_name", func(t *testing.T) {
			fx.maybeSkip(t)
			parent := fx.nextParent(t, false)
			msg := fx.Create(parent)
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
			container.ProtoReflect().Clear(fd)
			_, err := fx.Service().CreateTensorboard(fx.Context(), &CreateTensorboardRequest{
				Parent:      parent,
				Tensorboard: msg,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
		t.Run(".encryption_spec.kms_key_name", func(t *testing.T) {
			fx.maybeSkip(t)
			parent := fx.nextParent(t, false)
			msg := fx.Create(parent)
			container := msg.GetEncryptionSpec()
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("kms_key_name")
			container.ProtoReflect().Clear(fd)
			_, err := fx.Service().CreateTensorboard(fx.Context(), &CreateTensorboardRequest{
				Parent:      parent,
				Tensorboard: msg,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
	})

}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) testGet(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboard(fx.Context(), &GetTensorboardRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboard(fx.Context(), &GetTensorboardRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be returned without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg, err := fx.Service().GetTensorboard(fx.Context(), &GetTensorboardRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, created, protocmp.Transform())
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().GetTensorboard(fx.Context(), &GetTensorboardRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboard(fx.Context(), &GetTensorboardRequest{
			Name: "projects/-/locations/-/tensorboards/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) testUpdate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = ""
		_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
			Tensorboard: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = "invalid resource name"
		_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
			Tensorboard: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with Aborted if the supplied etag doesnt match the current etag value.
	t.Run("etag mismatch", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
			Tensorboard: msg,
		})
		assert.Equal(t, codes.Aborted, status.Code(err), err)
	})

	// Field etag should have a new value when the resource is successfully updated.
	t.Run("etag updated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		updated, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
			Tensorboard: msg,
		})
		assert.NilError(t, err)
		_ = updated
	})

	{
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		// Method should fail with NotFound if the resource does not exist.
		t.Run("not found", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Update(parent)
			msg.Name = created.Name + "notfound"
			_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
				Tensorboard: msg,
			})
			assert.Equal(t, codes.NotFound, status.Code(err), err)
		})

		// The method should fail with InvalidArgument if the update_mask is invalid.
		t.Run("invalid update mask", func(t *testing.T) {
			fx.maybeSkip(t)
			_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
				Tensorboard: created,
				UpdateMask: &fieldmaskpb.FieldMask{
					Paths: []string{
						"invalid_field_xyz",
					},
				},
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})

		// Method should fail with InvalidArgument if any required field is missing
		// when called with '*' update_mask.
		t.Run("required fields", func(t *testing.T) {
			fx.maybeSkip(t)
			t.Run(".display_name", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*Tensorboard)
				container := msg
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
					Tensorboard: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
			t.Run(".encryption_spec.kms_key_name", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*Tensorboard)
				container := msg.GetEncryptionSpec()
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("kms_key_name")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateTensorboard(fx.Context(), &UpdateTensorboardRequest{
					Tensorboard: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
		})

	}
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) testList(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
			Parent: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page token is not valid.
	t.Run("invalid page token", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
			Parent:    parent,
			PageToken: "invalid page token",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page size is negative.
	t.Run("negative page size", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
			Parent:   parent,
			PageSize: -10,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	{
		const resourcesCount = 15
		parent := fx.nextParent(t, true)
		parentMsgs := make([]*Tensorboard, resourcesCount)
		for i := 0; i < resourcesCount; i++ {
			parentMsgs[i] = fx.create(t, parent)
		}

		// If parent is provided the method must only return resources
		// under that parent.
		t.Run("isolation", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
				Parent:   parent,
				PageSize: 999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs,
				response.Tensorboards,
				cmpopts.SortSlices(func(a, b *Tensorboard) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// If there are no more resources, next_page_token should not be set.
		t.Run("last page", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
				Parent:   parent,
				PageSize: resourcesCount,
			})
			assert.NilError(t, err)
			assert.Equal(t, "", response.NextPageToken)
		})

		// If there are more resources, next_page_token should be set.
		t.Run("more pages", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
				Parent:   parent,
				PageSize: resourcesCount - 1,
			})
			assert.NilError(t, err)
			assert.Check(t, response.NextPageToken != "")
		})

		// Listing resource one by one should eventually return all resources.
		t.Run("one by one", func(t *testing.T) {
			fx.maybeSkip(t)
			msgs := make([]*Tensorboard, 0, resourcesCount)
			var nextPageToken string
			for {
				response, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
					Parent:    parent,
					PageSize:  1,
					PageToken: nextPageToken,
				})
				assert.NilError(t, err)
				assert.Equal(t, 1, len(response.Tensorboards))
				msgs = append(msgs, response.Tensorboards...)
				nextPageToken = response.NextPageToken
				if nextPageToken == "" {
					break
				}
			}
			assert.DeepEqual(
				t,
				parentMsgs,
				msgs,
				cmpopts.SortSlices(func(a, b *Tensorboard) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// Method should not return deleted resources.
		t.Run("deleted", func(t *testing.T) {
			fx.maybeSkip(t)
			const deleteCount = 5
			for i := 0; i < deleteCount; i++ {
				_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
					Name: parentMsgs[i].Name,
				})
				assert.NilError(t, err)
			}
			response, err := fx.Service().ListTensorboards(fx.Context(), &ListTensorboardsRequest{
				Parent:   parent,
				PageSize: 9999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs[deleteCount:],
				response.Tensorboards,
				cmpopts.SortSlices(func(a, b *Tensorboard) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

	}
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) testDelete(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be deleted without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with NotFound if the resource was already deleted. This also applies to soft-deletion.
	t.Run("already deleted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		deleted, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		_ = deleted
		_, err = fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: created.Name,
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboard(fx.Context(), &DeleteTensorboardRequest{
			Name: "projects/-/locations/-/tensorboards/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) nextParent(t *testing.T, pristine bool) string {
	if pristine {
		fx.currParent++
	}
	if fx.currParent >= len(fx.Parents) {
		t.Fatal("need at least", fx.currParent+1, "parents")
	}
	return fx.Parents[fx.currParent]
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) peekNextParent(t *testing.T) string {
	next := fx.currParent + 1
	if next >= len(fx.Parents) {
		t.Fatal("need at least", next+1, "parents")
	}
	return fx.Parents[next]
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) maybeSkip(t *testing.T) {
	for _, skip := range fx.Skip {
		if strings.Contains(t.Name(), skip) {
			t.Skip("skipped because of .Skip")
		}
	}
}

func (fx *TensorboardServiceTensorboardTestSuiteConfig) create(t *testing.T, parent string) *Tensorboard {
	t.Helper()
	t.Skip("Long running create method not supported")
	return nil
}

type TensorboardServiceTensorboardExperimentTestSuiteConfig struct {
	currParent int

	// Service should return the service that should be tested.
	// The service will be used for several tests.
	Service func() TensorboardServiceServer
	// Context should return a new context.
	// The context will be used for several tests.
	Context func() context.Context
	// The parents to use when creating resources.
	// At least one parent needs to be set. Depending on methods available on the resource,
	// more may be required. If insufficient number of parents are
	// provided the test will fail.
	Parents []string
	// Create should return a resource which is valid to create, i.e.
	// all required fields set.
	Create func(parent string) *TensorboardExperiment
	// Update should return a resource which is valid to update, i.e.
	// all required fields set.
	Update func(parent string) *TensorboardExperiment
	// Patterns of tests to skip.
	// For example if a service has a Get method:
	// Skip: ["Get"] will skip all tests for Get.
	// Skip: ["Get/persisted"] will only skip the subtest called "persisted" of Get.
	Skip []string
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) test(t *testing.T) {
	t.Run("Create", fx.testCreate)
	t.Run("Get", fx.testGet)
	t.Run("Update", fx.testUpdate)
	t.Run("List", fx.testList)
	t.Run("Delete", fx.testDelete)
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) testCreate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no parent is provided.
	t.Run("missing parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
			Parent:                "",
			TensorboardExperiment: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
			Parent:                "invalid resource name",
			TensorboardExperiment: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field create_time should be populated when the resource is created.
	t.Run("create time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		beforeCreate := time.Now()
		msg, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
			Parent:                parent,
			TensorboardExperiment: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, msg.CreateTime != nil)
		assert.Check(t, !msg.CreateTime.AsTime().IsZero())
		assert.Check(t, msg.CreateTime.AsTime().After(beforeCreate), "msg.CreateTime (%v) is not after beforeCreate (%v)", msg.CreateTime.AsTime(), beforeCreate)
	})

	// The created resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
			Parent:                parent,
			TensorboardExperiment: fx.Create(parent),
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: msg.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, persisted, protocmp.Transform())
	})

	// Field etag should be populated when the resource is created.
	t.Run("etag populated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
			Parent:                parent,
			TensorboardExperiment: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, created.Etag != "")
	})

}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) testGet(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be returned without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, created, protocmp.Transform())
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) testUpdate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = ""
		_, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = "invalid resource name"
		_, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field update_time should be updated when the resource is updated.
	t.Run("update time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: created,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.UpdateTime.AsTime().After(created.UpdateTime.AsTime()))
	})

	// The updated resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: created,
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardExperiment(fx.Context(), &GetTensorboardExperimentRequest{
			Name: updated.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, updated, persisted, protocmp.Transform())
	})

	// Method should fail with Aborted if the supplied etag doesnt match the current etag value.
	t.Run("etag mismatch", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = `"99999"`
		_, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: msg,
		})
		assert.Equal(t, codes.Aborted, status.Code(err), err)
	})

	// Field etag should have a new value when the resource is successfully updated.
	t.Run("etag updated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = created.Etag
		updated, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
			TensorboardExperiment: msg,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.Etag != created.Etag)
	})

	{
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		// Method should fail with NotFound if the resource does not exist.
		t.Run("not found", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Update(parent)
			msg.Name = created.Name + "notfound"
			_, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
				TensorboardExperiment: msg,
			})
			assert.Equal(t, codes.NotFound, status.Code(err), err)
		})

		// The method should fail with InvalidArgument if the update_mask is invalid.
		t.Run("invalid update mask", func(t *testing.T) {
			fx.maybeSkip(t)
			_, err := fx.Service().UpdateTensorboardExperiment(fx.Context(), &UpdateTensorboardExperimentRequest{
				TensorboardExperiment: created,
				UpdateMask: &fieldmaskpb.FieldMask{
					Paths: []string{
						"invalid_field_xyz",
					},
				},
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})

	}
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) testList(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
			Parent: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page token is not valid.
	t.Run("invalid page token", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
			Parent:    parent,
			PageToken: "invalid page token",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page size is negative.
	t.Run("negative page size", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
			Parent:   parent,
			PageSize: -10,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	{
		const resourcesCount = 15
		parent := fx.nextParent(t, true)
		parentMsgs := make([]*TensorboardExperiment, resourcesCount)
		for i := 0; i < resourcesCount; i++ {
			parentMsgs[i] = fx.create(t, parent)
		}

		// If parent is provided the method must only return resources
		// under that parent.
		t.Run("isolation", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
				Parent:   parent,
				PageSize: 999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs,
				response.TensorboardExperiments,
				cmpopts.SortSlices(func(a, b *TensorboardExperiment) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// If there are no more resources, next_page_token should not be set.
		t.Run("last page", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
				Parent:   parent,
				PageSize: resourcesCount,
			})
			assert.NilError(t, err)
			assert.Equal(t, "", response.NextPageToken)
		})

		// If there are more resources, next_page_token should be set.
		t.Run("more pages", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
				Parent:   parent,
				PageSize: resourcesCount - 1,
			})
			assert.NilError(t, err)
			assert.Check(t, response.NextPageToken != "")
		})

		// Listing resource one by one should eventually return all resources.
		t.Run("one by one", func(t *testing.T) {
			fx.maybeSkip(t)
			msgs := make([]*TensorboardExperiment, 0, resourcesCount)
			var nextPageToken string
			for {
				response, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
					Parent:    parent,
					PageSize:  1,
					PageToken: nextPageToken,
				})
				assert.NilError(t, err)
				assert.Equal(t, 1, len(response.TensorboardExperiments))
				msgs = append(msgs, response.TensorboardExperiments...)
				nextPageToken = response.NextPageToken
				if nextPageToken == "" {
					break
				}
			}
			assert.DeepEqual(
				t,
				parentMsgs,
				msgs,
				cmpopts.SortSlices(func(a, b *TensorboardExperiment) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// Method should not return deleted resources.
		t.Run("deleted", func(t *testing.T) {
			fx.maybeSkip(t)
			const deleteCount = 5
			for i := 0; i < deleteCount; i++ {
				_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
					Name: parentMsgs[i].Name,
				})
				assert.NilError(t, err)
			}
			response, err := fx.Service().ListTensorboardExperiments(fx.Context(), &ListTensorboardExperimentsRequest{
				Parent:   parent,
				PageSize: 9999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs[deleteCount:],
				response.TensorboardExperiments,
				cmpopts.SortSlices(func(a, b *TensorboardExperiment) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

	}
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) testDelete(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be deleted without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with NotFound if the resource was already deleted. This also applies to soft-deletion.
	t.Run("already deleted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		deleted, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		_ = deleted
		_, err = fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: created.Name,
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardExperiment(fx.Context(), &DeleteTensorboardExperimentRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) nextParent(t *testing.T, pristine bool) string {
	if pristine {
		fx.currParent++
	}
	if fx.currParent >= len(fx.Parents) {
		t.Fatal("need at least", fx.currParent+1, "parents")
	}
	return fx.Parents[fx.currParent]
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) peekNextParent(t *testing.T) string {
	next := fx.currParent + 1
	if next >= len(fx.Parents) {
		t.Fatal("need at least", next+1, "parents")
	}
	return fx.Parents[next]
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) maybeSkip(t *testing.T) {
	for _, skip := range fx.Skip {
		if strings.Contains(t.Name(), skip) {
			t.Skip("skipped because of .Skip")
		}
	}
}

func (fx *TensorboardServiceTensorboardExperimentTestSuiteConfig) create(t *testing.T, parent string) *TensorboardExperiment {
	t.Helper()
	created, err := fx.Service().CreateTensorboardExperiment(fx.Context(), &CreateTensorboardExperimentRequest{
		Parent:                parent,
		TensorboardExperiment: fx.Create(parent),
	})
	assert.NilError(t, err)
	return created
}

type TensorboardServiceTensorboardRunTestSuiteConfig struct {
	currParent int

	// Service should return the service that should be tested.
	// The service will be used for several tests.
	Service func() TensorboardServiceServer
	// Context should return a new context.
	// The context will be used for several tests.
	Context func() context.Context
	// The parents to use when creating resources.
	// At least one parent needs to be set. Depending on methods available on the resource,
	// more may be required. If insufficient number of parents are
	// provided the test will fail.
	Parents []string
	// Create should return a resource which is valid to create, i.e.
	// all required fields set.
	Create func(parent string) *TensorboardRun
	// Update should return a resource which is valid to update, i.e.
	// all required fields set.
	Update func(parent string) *TensorboardRun
	// Patterns of tests to skip.
	// For example if a service has a Get method:
	// Skip: ["Get"] will skip all tests for Get.
	// Skip: ["Get/persisted"] will only skip the subtest called "persisted" of Get.
	Skip []string
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) test(t *testing.T) {
	t.Run("Create", fx.testCreate)
	t.Run("Get", fx.testGet)
	t.Run("Update", fx.testUpdate)
	t.Run("List", fx.testList)
	t.Run("Delete", fx.testDelete)
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) testCreate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no parent is provided.
	t.Run("missing parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
			Parent:         "",
			TensorboardRun: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
			Parent:         "invalid resource name",
			TensorboardRun: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field create_time should be populated when the resource is created.
	t.Run("create time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		beforeCreate := time.Now()
		msg, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
			Parent:         parent,
			TensorboardRun: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, msg.CreateTime != nil)
		assert.Check(t, !msg.CreateTime.AsTime().IsZero())
		assert.Check(t, msg.CreateTime.AsTime().After(beforeCreate), "msg.CreateTime (%v) is not after beforeCreate (%v)", msg.CreateTime.AsTime(), beforeCreate)
	})

	// The created resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
			Parent:         parent,
			TensorboardRun: fx.Create(parent),
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: msg.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, persisted, protocmp.Transform())
	})

	// The method should fail with InvalidArgument if the resource has any
	// required fields and they are not provided.
	t.Run("required fields", func(t *testing.T) {
		fx.maybeSkip(t)
		t.Run(".display_name", func(t *testing.T) {
			fx.maybeSkip(t)
			parent := fx.nextParent(t, false)
			msg := fx.Create(parent)
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
			container.ProtoReflect().Clear(fd)
			_, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
				Parent:         parent,
				TensorboardRun: msg,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
	})

	// Field etag should be populated when the resource is created.
	t.Run("etag populated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
			Parent:         parent,
			TensorboardRun: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, created.Etag != "")
	})

}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) testGet(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be returned without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, created, protocmp.Transform())
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-/runs/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) testUpdate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = ""
		_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = "invalid resource name"
		_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field update_time should be updated when the resource is updated.
	t.Run("update time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: created,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.UpdateTime.AsTime().After(created.UpdateTime.AsTime()))
	})

	// The updated resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: created,
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardRun(fx.Context(), &GetTensorboardRunRequest{
			Name: updated.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, updated, persisted, protocmp.Transform())
	})

	// The field create_time should be preserved when a '*'-update mask is used.
	t.Run("preserve create_time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		originalCreateTime := created.CreateTime
		updated, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: created,
			UpdateMask: &fieldmaskpb.FieldMask{
				Paths: []string{
					"*",
				},
			},
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, originalCreateTime, updated.CreateTime, protocmp.Transform())
	})

	// Method should fail with Aborted if the supplied etag doesnt match the current etag value.
	t.Run("etag mismatch", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = `"99999"`
		_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: msg,
		})
		assert.Equal(t, codes.Aborted, status.Code(err), err)
	})

	// Field etag should have a new value when the resource is successfully updated.
	t.Run("etag updated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = created.Etag
		updated, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
			TensorboardRun: msg,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.Etag != created.Etag)
	})

	{
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		// Method should fail with NotFound if the resource does not exist.
		t.Run("not found", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Update(parent)
			msg.Name = created.Name + "notfound"
			_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
				TensorboardRun: msg,
			})
			assert.Equal(t, codes.NotFound, status.Code(err), err)
		})

		// The method should fail with InvalidArgument if the update_mask is invalid.
		t.Run("invalid update mask", func(t *testing.T) {
			fx.maybeSkip(t)
			_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
				TensorboardRun: created,
				UpdateMask: &fieldmaskpb.FieldMask{
					Paths: []string{
						"invalid_field_xyz",
					},
				},
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})

		// Method should fail with InvalidArgument if any required field is missing
		// when called with '*' update_mask.
		t.Run("required fields", func(t *testing.T) {
			fx.maybeSkip(t)
			t.Run(".display_name", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*TensorboardRun)
				container := msg
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateTensorboardRun(fx.Context(), &UpdateTensorboardRunRequest{
					TensorboardRun: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
		})

	}
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) testList(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
			Parent: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page token is not valid.
	t.Run("invalid page token", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
			Parent:    parent,
			PageToken: "invalid page token",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page size is negative.
	t.Run("negative page size", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
			Parent:   parent,
			PageSize: -10,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	{
		const resourcesCount = 15
		parent := fx.nextParent(t, true)
		parentMsgs := make([]*TensorboardRun, resourcesCount)
		for i := 0; i < resourcesCount; i++ {
			parentMsgs[i] = fx.create(t, parent)
		}

		// If parent is provided the method must only return resources
		// under that parent.
		t.Run("isolation", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
				Parent:   parent,
				PageSize: 999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs,
				response.TensorboardRuns,
				cmpopts.SortSlices(func(a, b *TensorboardRun) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// If there are no more resources, next_page_token should not be set.
		t.Run("last page", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
				Parent:   parent,
				PageSize: resourcesCount,
			})
			assert.NilError(t, err)
			assert.Equal(t, "", response.NextPageToken)
		})

		// If there are more resources, next_page_token should be set.
		t.Run("more pages", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
				Parent:   parent,
				PageSize: resourcesCount - 1,
			})
			assert.NilError(t, err)
			assert.Check(t, response.NextPageToken != "")
		})

		// Listing resource one by one should eventually return all resources.
		t.Run("one by one", func(t *testing.T) {
			fx.maybeSkip(t)
			msgs := make([]*TensorboardRun, 0, resourcesCount)
			var nextPageToken string
			for {
				response, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
					Parent:    parent,
					PageSize:  1,
					PageToken: nextPageToken,
				})
				assert.NilError(t, err)
				assert.Equal(t, 1, len(response.TensorboardRuns))
				msgs = append(msgs, response.TensorboardRuns...)
				nextPageToken = response.NextPageToken
				if nextPageToken == "" {
					break
				}
			}
			assert.DeepEqual(
				t,
				parentMsgs,
				msgs,
				cmpopts.SortSlices(func(a, b *TensorboardRun) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// Method should not return deleted resources.
		t.Run("deleted", func(t *testing.T) {
			fx.maybeSkip(t)
			const deleteCount = 5
			for i := 0; i < deleteCount; i++ {
				_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
					Name: parentMsgs[i].Name,
				})
				assert.NilError(t, err)
			}
			response, err := fx.Service().ListTensorboardRuns(fx.Context(), &ListTensorboardRunsRequest{
				Parent:   parent,
				PageSize: 9999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs[deleteCount:],
				response.TensorboardRuns,
				cmpopts.SortSlices(func(a, b *TensorboardRun) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

	}
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) testDelete(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be deleted without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with NotFound if the resource was already deleted. This also applies to soft-deletion.
	t.Run("already deleted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		deleted, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		_ = deleted
		_, err = fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: created.Name,
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardRun(fx.Context(), &DeleteTensorboardRunRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-/runs/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) nextParent(t *testing.T, pristine bool) string {
	if pristine {
		fx.currParent++
	}
	if fx.currParent >= len(fx.Parents) {
		t.Fatal("need at least", fx.currParent+1, "parents")
	}
	return fx.Parents[fx.currParent]
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) peekNextParent(t *testing.T) string {
	next := fx.currParent + 1
	if next >= len(fx.Parents) {
		t.Fatal("need at least", next+1, "parents")
	}
	return fx.Parents[next]
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) maybeSkip(t *testing.T) {
	for _, skip := range fx.Skip {
		if strings.Contains(t.Name(), skip) {
			t.Skip("skipped because of .Skip")
		}
	}
}

func (fx *TensorboardServiceTensorboardRunTestSuiteConfig) create(t *testing.T, parent string) *TensorboardRun {
	t.Helper()
	created, err := fx.Service().CreateTensorboardRun(fx.Context(), &CreateTensorboardRunRequest{
		Parent:         parent,
		TensorboardRun: fx.Create(parent),
	})
	assert.NilError(t, err)
	return created
}

type TensorboardServiceTensorboardTimeSeriesTestSuiteConfig struct {
	currParent int

	// Service should return the service that should be tested.
	// The service will be used for several tests.
	Service func() TensorboardServiceServer
	// Context should return a new context.
	// The context will be used for several tests.
	Context func() context.Context
	// The parents to use when creating resources.
	// At least one parent needs to be set. Depending on methods available on the resource,
	// more may be required. If insufficient number of parents are
	// provided the test will fail.
	Parents []string
	// Create should return a resource which is valid to create, i.e.
	// all required fields set.
	Create func(parent string) *TensorboardTimeSeries
	// Update should return a resource which is valid to update, i.e.
	// all required fields set.
	Update func(parent string) *TensorboardTimeSeries
	// Patterns of tests to skip.
	// For example if a service has a Get method:
	// Skip: ["Get"] will skip all tests for Get.
	// Skip: ["Get/persisted"] will only skip the subtest called "persisted" of Get.
	Skip []string
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) test(t *testing.T) {
	t.Run("Create", fx.testCreate)
	t.Run("Get", fx.testGet)
	t.Run("Update", fx.testUpdate)
	t.Run("List", fx.testList)
	t.Run("Delete", fx.testDelete)
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) testCreate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no parent is provided.
	t.Run("missing parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
			Parent:                "",
			TensorboardTimeSeries: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
			Parent:                "invalid resource name",
			TensorboardTimeSeries: fx.Create(fx.nextParent(t, false)),
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field create_time should be populated when the resource is created.
	t.Run("create time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		beforeCreate := time.Now()
		msg, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
			Parent:                parent,
			TensorboardTimeSeries: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, msg.CreateTime != nil)
		assert.Check(t, !msg.CreateTime.AsTime().IsZero())
		assert.Check(t, msg.CreateTime.AsTime().After(beforeCreate), "msg.CreateTime (%v) is not after beforeCreate (%v)", msg.CreateTime.AsTime(), beforeCreate)
	})

	// The created resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
			Parent:                parent,
			TensorboardTimeSeries: fx.Create(parent),
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: msg.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, persisted, protocmp.Transform())
	})

	// The method should fail with InvalidArgument if the resource has any
	// required fields and they are not provided.
	t.Run("required fields", func(t *testing.T) {
		fx.maybeSkip(t)
		t.Run(".display_name", func(t *testing.T) {
			fx.maybeSkip(t)
			parent := fx.nextParent(t, false)
			msg := fx.Create(parent)
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
			container.ProtoReflect().Clear(fd)
			_, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
				Parent:                parent,
				TensorboardTimeSeries: msg,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
		t.Run(".value_type", func(t *testing.T) {
			fx.maybeSkip(t)
			parent := fx.nextParent(t, false)
			msg := fx.Create(parent)
			container := msg
			if container == nil {
				t.Skip("not reachable")
			}
			fd := container.ProtoReflect().Descriptor().Fields().ByName("value_type")
			container.ProtoReflect().Clear(fd)
			_, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
				Parent:                parent,
				TensorboardTimeSeries: msg,
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})
	})

	// Field etag should be populated when the resource is created.
	t.Run("etag populated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
			Parent:                parent,
			TensorboardTimeSeries: fx.Create(parent),
		})
		assert.NilError(t, err)
		assert.Check(t, created.Etag != "")
	})

}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) testGet(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be returned without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, msg, created, protocmp.Transform())
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-/runs/-/timeSeries/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) testUpdate(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = ""
		_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		msg := fx.Update(parent)
		msg.Name = "invalid resource name"
		_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: msg,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Field update_time should be updated when the resource is updated.
	t.Run("update time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: created,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.UpdateTime.AsTime().After(created.UpdateTime.AsTime()))
	})

	// The updated resource should be persisted and reachable with Get.
	t.Run("persisted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		updated, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: created,
		})
		assert.NilError(t, err)
		persisted, err := fx.Service().GetTensorboardTimeSeries(fx.Context(), &GetTensorboardTimeSeriesRequest{
			Name: updated.Name,
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, updated, persisted, protocmp.Transform())
	})

	// The field create_time should be preserved when a '*'-update mask is used.
	t.Run("preserve create_time", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		originalCreateTime := created.CreateTime
		updated, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: created,
			UpdateMask: &fieldmaskpb.FieldMask{
				Paths: []string{
					"*",
				},
			},
		})
		assert.NilError(t, err)
		assert.DeepEqual(t, originalCreateTime, updated.CreateTime, protocmp.Transform())
	})

	// Method should fail with Aborted if the supplied etag doesnt match the current etag value.
	t.Run("etag mismatch", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = `"99999"`
		_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: msg,
		})
		assert.Equal(t, codes.Aborted, status.Code(err), err)
	})

	// Field etag should have a new value when the resource is successfully updated.
	t.Run("etag updated", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		msg := fx.Update(parent)
		msg.Name = created.Name
		msg.Etag = created.Etag
		updated, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
			TensorboardTimeSeries: msg,
		})
		assert.NilError(t, err)
		assert.Check(t, updated.Etag != created.Etag)
	})

	{
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		// Method should fail with NotFound if the resource does not exist.
		t.Run("not found", func(t *testing.T) {
			fx.maybeSkip(t)
			msg := fx.Update(parent)
			msg.Name = created.Name + "notfound"
			_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
				TensorboardTimeSeries: msg,
			})
			assert.Equal(t, codes.NotFound, status.Code(err), err)
		})

		// The method should fail with InvalidArgument if the update_mask is invalid.
		t.Run("invalid update mask", func(t *testing.T) {
			fx.maybeSkip(t)
			_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
				TensorboardTimeSeries: created,
				UpdateMask: &fieldmaskpb.FieldMask{
					Paths: []string{
						"invalid_field_xyz",
					},
				},
			})
			assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
		})

		// Method should fail with InvalidArgument if any required field is missing
		// when called with '*' update_mask.
		t.Run("required fields", func(t *testing.T) {
			fx.maybeSkip(t)
			t.Run(".display_name", func(t *testing.T) {
				fx.maybeSkip(t)
				msg := proto.Clone(created).(*TensorboardTimeSeries)
				container := msg
				if container == nil {
					t.Skip("not reachable")
				}
				fd := container.ProtoReflect().Descriptor().Fields().ByName("display_name")
				container.ProtoReflect().Clear(fd)
				_, err := fx.Service().UpdateTensorboardTimeSeries(fx.Context(), &UpdateTensorboardTimeSeriesRequest{
					TensorboardTimeSeries: msg,
					UpdateMask: &fieldmaskpb.FieldMask{
						Paths: []string{
							"*",
						},
					},
				})
				assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
			})
		})

	}
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) testList(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if provided parent is invalid.
	t.Run("invalid parent", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
			Parent: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page token is not valid.
	t.Run("invalid page token", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
			Parent:    parent,
			PageToken: "invalid page token",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument is provided page size is negative.
	t.Run("negative page size", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		_, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
			Parent:   parent,
			PageSize: -10,
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	{
		const resourcesCount = 15
		parent := fx.nextParent(t, true)
		parentMsgs := make([]*TensorboardTimeSeries, resourcesCount)
		for i := 0; i < resourcesCount; i++ {
			parentMsgs[i] = fx.create(t, parent)
		}

		// If parent is provided the method must only return resources
		// under that parent.
		t.Run("isolation", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
				Parent:   parent,
				PageSize: 999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs,
				response.TensorboardTimeSeries,
				cmpopts.SortSlices(func(a, b *TensorboardTimeSeries) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// If there are no more resources, next_page_token should not be set.
		t.Run("last page", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
				Parent:   parent,
				PageSize: resourcesCount,
			})
			assert.NilError(t, err)
			assert.Equal(t, "", response.NextPageToken)
		})

		// If there are more resources, next_page_token should be set.
		t.Run("more pages", func(t *testing.T) {
			fx.maybeSkip(t)
			response, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
				Parent:   parent,
				PageSize: resourcesCount - 1,
			})
			assert.NilError(t, err)
			assert.Check(t, response.NextPageToken != "")
		})

		// Listing resource one by one should eventually return all resources.
		t.Run("one by one", func(t *testing.T) {
			fx.maybeSkip(t)
			msgs := make([]*TensorboardTimeSeries, 0, resourcesCount)
			var nextPageToken string
			for {
				response, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
					Parent:    parent,
					PageSize:  1,
					PageToken: nextPageToken,
				})
				assert.NilError(t, err)
				assert.Equal(t, 1, len(response.TensorboardTimeSeries))
				msgs = append(msgs, response.TensorboardTimeSeries...)
				nextPageToken = response.NextPageToken
				if nextPageToken == "" {
					break
				}
			}
			assert.DeepEqual(
				t,
				parentMsgs,
				msgs,
				cmpopts.SortSlices(func(a, b *TensorboardTimeSeries) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

		// Method should not return deleted resources.
		t.Run("deleted", func(t *testing.T) {
			fx.maybeSkip(t)
			const deleteCount = 5
			for i := 0; i < deleteCount; i++ {
				_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
					Name: parentMsgs[i].Name,
				})
				assert.NilError(t, err)
			}
			response, err := fx.Service().ListTensorboardTimeSeries(fx.Context(), &ListTensorboardTimeSeriesRequest{
				Parent:   parent,
				PageSize: 9999,
			})
			assert.NilError(t, err)
			assert.DeepEqual(
				t,
				parentMsgs[deleteCount:],
				response.TensorboardTimeSeries,
				cmpopts.SortSlices(func(a, b *TensorboardTimeSeries) bool {
					return a.Name < b.Name
				}),
				protocmp.Transform(),
			)
		})

	}
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) testDelete(t *testing.T) {
	fx.maybeSkip(t)
	// Method should fail with InvalidArgument if no name is provided.
	t.Run("missing name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: "",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name is not valid.
	t.Run("invalid name", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: "invalid resource name",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

	// Resource should be deleted without errors if it exists.
	t.Run("exists", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
	})

	// Method should fail with NotFound if the resource does not exist.
	t.Run("not found", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: created.Name + "notfound",
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with NotFound if the resource was already deleted. This also applies to soft-deletion.
	t.Run("already deleted", func(t *testing.T) {
		fx.maybeSkip(t)
		parent := fx.nextParent(t, false)
		created := fx.create(t, parent)
		deleted, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: created.Name,
		})
		assert.NilError(t, err)
		_ = deleted
		_, err = fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: created.Name,
		})
		assert.Equal(t, codes.NotFound, status.Code(err), err)
	})

	// Method should fail with InvalidArgument if the provided name only contains wildcards ('-')
	t.Run("only wildcards", func(t *testing.T) {
		fx.maybeSkip(t)
		_, err := fx.Service().DeleteTensorboardTimeSeries(fx.Context(), &DeleteTensorboardTimeSeriesRequest{
			Name: "projects/-/locations/-/tensorboards/-/experiments/-/runs/-/timeSeries/-",
		})
		assert.Equal(t, codes.InvalidArgument, status.Code(err), err)
	})

}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) nextParent(t *testing.T, pristine bool) string {
	if pristine {
		fx.currParent++
	}
	if fx.currParent >= len(fx.Parents) {
		t.Fatal("need at least", fx.currParent+1, "parents")
	}
	return fx.Parents[fx.currParent]
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) peekNextParent(t *testing.T) string {
	next := fx.currParent + 1
	if next >= len(fx.Parents) {
		t.Fatal("need at least", next+1, "parents")
	}
	return fx.Parents[next]
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) maybeSkip(t *testing.T) {
	for _, skip := range fx.Skip {
		if strings.Contains(t.Name(), skip) {
			t.Skip("skipped because of .Skip")
		}
	}
}

func (fx *TensorboardServiceTensorboardTimeSeriesTestSuiteConfig) create(t *testing.T, parent string) *TensorboardTimeSeries {
	t.Helper()
	created, err := fx.Service().CreateTensorboardTimeSeries(fx.Context(), &CreateTensorboardTimeSeriesRequest{
		Parent:                parent,
		TensorboardTimeSeries: fx.Create(parent),
	})
	assert.NilError(t, err)
	return created
}

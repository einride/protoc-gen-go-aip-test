// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package instance

import (
	context "context"
	v1 "google.golang.org/genproto/googleapis/iam/v1"
	longrunning "google.golang.org/genproto/googleapis/longrunning"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InstanceAdminClient is the client API for InstanceAdmin service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceAdminClient interface {
	// Lists the supported instance configurations for a given project.
	ListInstanceConfigs(ctx context.Context, in *ListInstanceConfigsRequest, opts ...grpc.CallOption) (*ListInstanceConfigsResponse, error)
	// Gets information about a particular instance configuration.
	GetInstanceConfig(ctx context.Context, in *GetInstanceConfigRequest, opts ...grpc.CallOption) (*InstanceConfig, error)
	// Lists all instances in the given project.
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// Gets information about a particular instance.
	GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error)
	// Creates an instance and begins preparing it to begin serving. The
	// returned [long-running operation][google.longrunning.Operation]
	// can be used to track the progress of preparing the new
	// instance. The instance name is assigned by the caller. If the
	// named instance already exists, `CreateInstance` returns
	// `ALREADY_EXISTS`.
	//
	// Immediately upon completion of this request:
	//
	//   * The instance is readable via the API, with all requested attributes
	//     but no allocated resources. Its state is `CREATING`.
	//
	// Until completion of the returned operation:
	//
	//   * Cancelling the operation renders the instance immediately unreadable
	//     via the API.
	//   * The instance can be deleted.
	//   * All other attempts to modify the instance are rejected.
	//
	// Upon completion of the returned operation:
	//
	//   * Billing for all successfully-allocated resources begins (some types
	//     may have lower than the requested levels).
	//   * Databases can be created in the instance.
	//   * The instance's allocated resource levels are readable via the API.
	//   * The instance's state becomes `READY`.
	//
	// The returned [long-running operation][google.longrunning.Operation] will
	// have a name of the format `<instance_name>/operations/<operation_id>` and
	// can be used to track creation of the instance.  The
	// [metadata][google.longrunning.Operation.metadata] field type is
	// [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
	// The [response][google.longrunning.Operation.response] field type is
	// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
	CreateInstance(ctx context.Context, in *CreateInstanceRequest, opts ...grpc.CallOption) (*longrunning.Operation, error)
	// Updates an instance, and begins allocating or releasing resources
	// as requested. The returned [long-running
	// operation][google.longrunning.Operation] can be used to track the
	// progress of updating the instance. If the named instance does not
	// exist, returns `NOT_FOUND`.
	//
	// Immediately upon completion of this request:
	//
	//   * For resource types for which a decrease in the instance's allocation
	//     has been requested, billing is based on the newly-requested level.
	//
	// Until completion of the returned operation:
	//
	//   * Cancelling the operation sets its metadata's
	//     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time], and begins
	//     restoring resources to their pre-request values. The operation
	//     is guaranteed to succeed at undoing all resource changes,
	//     after which point it terminates with a `CANCELLED` status.
	//   * All other attempts to modify the instance are rejected.
	//   * Reading the instance via the API continues to give the pre-request
	//     resource levels.
	//
	// Upon completion of the returned operation:
	//
	//   * Billing begins for all successfully-allocated resources (some types
	//     may have lower than the requested levels).
	//   * All newly-reserved resources are available for serving the instance's
	//     tables.
	//   * The instance's new resource levels are readable via the API.
	//
	// The returned [long-running operation][google.longrunning.Operation] will
	// have a name of the format `<instance_name>/operations/<operation_id>` and
	// can be used to track the instance modification.  The
	// [metadata][google.longrunning.Operation.metadata] field type is
	// [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
	// The [response][google.longrunning.Operation.response] field type is
	// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
	//
	// Authorization requires `spanner.instances.update` permission on
	// resource [name][google.spanner.admin.instance.v1.Instance.name].
	UpdateInstance(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*longrunning.Operation, error)
	// Deletes an instance.
	//
	// Immediately upon completion of the request:
	//
	//   * Billing ceases for all of the instance's reserved resources.
	//
	// Soon afterward:
	//
	//   * The instance and *all of its databases* immediately and
	//     irrevocably disappear from the API. All data in the databases
	//     is permanently deleted.
	DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Sets the access control policy on an instance resource. Replaces any
	// existing policy.
	//
	// Authorization requires `spanner.instances.setIamPolicy` on
	// [resource][google.iam.v1.SetIamPolicyRequest.resource].
	SetIamPolicy(ctx context.Context, in *v1.SetIamPolicyRequest, opts ...grpc.CallOption) (*v1.Policy, error)
	// Gets the access control policy for an instance resource. Returns an empty
	// policy if an instance exists but does not have a policy set.
	//
	// Authorization requires `spanner.instances.getIamPolicy` on
	// [resource][google.iam.v1.GetIamPolicyRequest.resource].
	GetIamPolicy(ctx context.Context, in *v1.GetIamPolicyRequest, opts ...grpc.CallOption) (*v1.Policy, error)
	// Returns permissions that the caller has on the specified instance resource.
	//
	// Attempting this RPC on a non-existent Cloud Spanner instance resource will
	// result in a NOT_FOUND error if the user has `spanner.instances.list`
	// permission on the containing Google Cloud Project. Otherwise returns an
	// empty set of permissions.
	TestIamPermissions(ctx context.Context, in *v1.TestIamPermissionsRequest, opts ...grpc.CallOption) (*v1.TestIamPermissionsResponse, error)
}

type instanceAdminClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceAdminClient(cc grpc.ClientConnInterface) InstanceAdminClient {
	return &instanceAdminClient{cc}
}

func (c *instanceAdminClient) ListInstanceConfigs(ctx context.Context, in *ListInstanceConfigsRequest, opts ...grpc.CallOption) (*ListInstanceConfigsResponse, error) {
	out := new(ListInstanceConfigsResponse)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/ListInstanceConfigs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) GetInstanceConfig(ctx context.Context, in *GetInstanceConfigRequest, opts ...grpc.CallOption) (*InstanceConfig, error) {
	out := new(InstanceConfig)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/GetInstanceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/ListInstances", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/GetInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) CreateInstance(ctx context.Context, in *CreateInstanceRequest, opts ...grpc.CallOption) (*longrunning.Operation, error) {
	out := new(longrunning.Operation)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/CreateInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) UpdateInstance(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*longrunning.Operation, error) {
	out := new(longrunning.Operation)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/UpdateInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) DeleteInstance(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) SetIamPolicy(ctx context.Context, in *v1.SetIamPolicyRequest, opts ...grpc.CallOption) (*v1.Policy, error) {
	out := new(v1.Policy)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/SetIamPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) GetIamPolicy(ctx context.Context, in *v1.GetIamPolicyRequest, opts ...grpc.CallOption) (*v1.Policy, error) {
	out := new(v1.Policy)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/GetIamPolicy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceAdminClient) TestIamPermissions(ctx context.Context, in *v1.TestIamPermissionsRequest, opts ...grpc.CallOption) (*v1.TestIamPermissionsResponse, error) {
	out := new(v1.TestIamPermissionsResponse)
	err := c.cc.Invoke(ctx, "/google.spanner.admin.instance.v1.InstanceAdmin/TestIamPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceAdminServer is the server API for InstanceAdmin service.
// All implementations must embed UnimplementedInstanceAdminServer
// for forward compatibility
type InstanceAdminServer interface {
	// Lists the supported instance configurations for a given project.
	ListInstanceConfigs(context.Context, *ListInstanceConfigsRequest) (*ListInstanceConfigsResponse, error)
	// Gets information about a particular instance configuration.
	GetInstanceConfig(context.Context, *GetInstanceConfigRequest) (*InstanceConfig, error)
	// Lists all instances in the given project.
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// Gets information about a particular instance.
	GetInstance(context.Context, *GetInstanceRequest) (*Instance, error)
	// Creates an instance and begins preparing it to begin serving. The
	// returned [long-running operation][google.longrunning.Operation]
	// can be used to track the progress of preparing the new
	// instance. The instance name is assigned by the caller. If the
	// named instance already exists, `CreateInstance` returns
	// `ALREADY_EXISTS`.
	//
	// Immediately upon completion of this request:
	//
	//   * The instance is readable via the API, with all requested attributes
	//     but no allocated resources. Its state is `CREATING`.
	//
	// Until completion of the returned operation:
	//
	//   * Cancelling the operation renders the instance immediately unreadable
	//     via the API.
	//   * The instance can be deleted.
	//   * All other attempts to modify the instance are rejected.
	//
	// Upon completion of the returned operation:
	//
	//   * Billing for all successfully-allocated resources begins (some types
	//     may have lower than the requested levels).
	//   * Databases can be created in the instance.
	//   * The instance's allocated resource levels are readable via the API.
	//   * The instance's state becomes `READY`.
	//
	// The returned [long-running operation][google.longrunning.Operation] will
	// have a name of the format `<instance_name>/operations/<operation_id>` and
	// can be used to track creation of the instance.  The
	// [metadata][google.longrunning.Operation.metadata] field type is
	// [CreateInstanceMetadata][google.spanner.admin.instance.v1.CreateInstanceMetadata].
	// The [response][google.longrunning.Operation.response] field type is
	// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
	CreateInstance(context.Context, *CreateInstanceRequest) (*longrunning.Operation, error)
	// Updates an instance, and begins allocating or releasing resources
	// as requested. The returned [long-running
	// operation][google.longrunning.Operation] can be used to track the
	// progress of updating the instance. If the named instance does not
	// exist, returns `NOT_FOUND`.
	//
	// Immediately upon completion of this request:
	//
	//   * For resource types for which a decrease in the instance's allocation
	//     has been requested, billing is based on the newly-requested level.
	//
	// Until completion of the returned operation:
	//
	//   * Cancelling the operation sets its metadata's
	//     [cancel_time][google.spanner.admin.instance.v1.UpdateInstanceMetadata.cancel_time], and begins
	//     restoring resources to their pre-request values. The operation
	//     is guaranteed to succeed at undoing all resource changes,
	//     after which point it terminates with a `CANCELLED` status.
	//   * All other attempts to modify the instance are rejected.
	//   * Reading the instance via the API continues to give the pre-request
	//     resource levels.
	//
	// Upon completion of the returned operation:
	//
	//   * Billing begins for all successfully-allocated resources (some types
	//     may have lower than the requested levels).
	//   * All newly-reserved resources are available for serving the instance's
	//     tables.
	//   * The instance's new resource levels are readable via the API.
	//
	// The returned [long-running operation][google.longrunning.Operation] will
	// have a name of the format `<instance_name>/operations/<operation_id>` and
	// can be used to track the instance modification.  The
	// [metadata][google.longrunning.Operation.metadata] field type is
	// [UpdateInstanceMetadata][google.spanner.admin.instance.v1.UpdateInstanceMetadata].
	// The [response][google.longrunning.Operation.response] field type is
	// [Instance][google.spanner.admin.instance.v1.Instance], if successful.
	//
	// Authorization requires `spanner.instances.update` permission on
	// resource [name][google.spanner.admin.instance.v1.Instance.name].
	UpdateInstance(context.Context, *UpdateInstanceRequest) (*longrunning.Operation, error)
	// Deletes an instance.
	//
	// Immediately upon completion of the request:
	//
	//   * Billing ceases for all of the instance's reserved resources.
	//
	// Soon afterward:
	//
	//   * The instance and *all of its databases* immediately and
	//     irrevocably disappear from the API. All data in the databases
	//     is permanently deleted.
	DeleteInstance(context.Context, *DeleteInstanceRequest) (*emptypb.Empty, error)
	// Sets the access control policy on an instance resource. Replaces any
	// existing policy.
	//
	// Authorization requires `spanner.instances.setIamPolicy` on
	// [resource][google.iam.v1.SetIamPolicyRequest.resource].
	SetIamPolicy(context.Context, *v1.SetIamPolicyRequest) (*v1.Policy, error)
	// Gets the access control policy for an instance resource. Returns an empty
	// policy if an instance exists but does not have a policy set.
	//
	// Authorization requires `spanner.instances.getIamPolicy` on
	// [resource][google.iam.v1.GetIamPolicyRequest.resource].
	GetIamPolicy(context.Context, *v1.GetIamPolicyRequest) (*v1.Policy, error)
	// Returns permissions that the caller has on the specified instance resource.
	//
	// Attempting this RPC on a non-existent Cloud Spanner instance resource will
	// result in a NOT_FOUND error if the user has `spanner.instances.list`
	// permission on the containing Google Cloud Project. Otherwise returns an
	// empty set of permissions.
	TestIamPermissions(context.Context, *v1.TestIamPermissionsRequest) (*v1.TestIamPermissionsResponse, error)
	mustEmbedUnimplementedInstanceAdminServer()
}

// UnimplementedInstanceAdminServer must be embedded to have forward compatible implementations.
type UnimplementedInstanceAdminServer struct {
}

func (UnimplementedInstanceAdminServer) ListInstanceConfigs(context.Context, *ListInstanceConfigsRequest) (*ListInstanceConfigsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstanceConfigs not implemented")
}
func (UnimplementedInstanceAdminServer) GetInstanceConfig(context.Context, *GetInstanceConfigRequest) (*InstanceConfig, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstanceConfig not implemented")
}
func (UnimplementedInstanceAdminServer) ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedInstanceAdminServer) GetInstance(context.Context, *GetInstanceRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstance not implemented")
}
func (UnimplementedInstanceAdminServer) CreateInstance(context.Context, *CreateInstanceRequest) (*longrunning.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInstance not implemented")
}
func (UnimplementedInstanceAdminServer) UpdateInstance(context.Context, *UpdateInstanceRequest) (*longrunning.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateInstance not implemented")
}
func (UnimplementedInstanceAdminServer) DeleteInstance(context.Context, *DeleteInstanceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstance not implemented")
}
func (UnimplementedInstanceAdminServer) SetIamPolicy(context.Context, *v1.SetIamPolicyRequest) (*v1.Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInstanceAdminServer) GetIamPolicy(context.Context, *v1.GetIamPolicyRequest) (*v1.Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInstanceAdminServer) TestIamPermissions(context.Context, *v1.TestIamPermissionsRequest) (*v1.TestIamPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedInstanceAdminServer) mustEmbedUnimplementedInstanceAdminServer() {}

// UnsafeInstanceAdminServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceAdminServer will
// result in compilation errors.
type UnsafeInstanceAdminServer interface {
	mustEmbedUnimplementedInstanceAdminServer()
}

func RegisterInstanceAdminServer(s grpc.ServiceRegistrar, srv InstanceAdminServer) {
	s.RegisterService(&InstanceAdmin_ServiceDesc, srv)
}

func _InstanceAdmin_ListInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstanceConfigsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).ListInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/ListInstanceConfigs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).ListInstanceConfigs(ctx, req.(*ListInstanceConfigsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_GetInstanceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).GetInstanceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/GetInstanceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).GetInstanceConfig(ctx, req.(*GetInstanceConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/ListInstances",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_GetInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).GetInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/GetInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).GetInstance(ctx, req.(*GetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_CreateInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).CreateInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/CreateInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).CreateInstance(ctx, req.(*CreateInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_UpdateInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).UpdateInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/UpdateInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).UpdateInstance(ctx, req.(*UpdateInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_DeleteInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).DeleteInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/DeleteInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).DeleteInstance(ctx, req.(*DeleteInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.SetIamPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/SetIamPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).SetIamPolicy(ctx, req.(*v1.SetIamPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.GetIamPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/GetIamPolicy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).GetIamPolicy(ctx, req.(*v1.GetIamPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceAdmin_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(v1.TestIamPermissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceAdminServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/google.spanner.admin.instance.v1.InstanceAdmin/TestIamPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceAdminServer).TestIamPermissions(ctx, req.(*v1.TestIamPermissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceAdmin_ServiceDesc is the grpc.ServiceDesc for InstanceAdmin service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceAdmin_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.spanner.admin.instance.v1.InstanceAdmin",
	HandlerType: (*InstanceAdminServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListInstanceConfigs",
			Handler:    _InstanceAdmin_ListInstanceConfigs_Handler,
		},
		{
			MethodName: "GetInstanceConfig",
			Handler:    _InstanceAdmin_GetInstanceConfig_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _InstanceAdmin_ListInstances_Handler,
		},
		{
			MethodName: "GetInstance",
			Handler:    _InstanceAdmin_GetInstance_Handler,
		},
		{
			MethodName: "CreateInstance",
			Handler:    _InstanceAdmin_CreateInstance_Handler,
		},
		{
			MethodName: "UpdateInstance",
			Handler:    _InstanceAdmin_UpdateInstance_Handler,
		},
		{
			MethodName: "DeleteInstance",
			Handler:    _InstanceAdmin_DeleteInstance_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _InstanceAdmin_SetIamPolicy_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _InstanceAdmin_GetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InstanceAdmin_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/spanner/admin/instance/v1/spanner_instance_admin.proto",
}
